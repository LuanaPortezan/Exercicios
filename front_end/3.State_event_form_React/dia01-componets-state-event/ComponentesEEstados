-------- Componentes e estados -----------

-- Introdu√ß√£o ao estado ---

<!-- v√≠deo sobre componentes com estado e eventos: introdu√ß√£o ao estado -->

O Estado de um componente √© um lugar especial que todo componente tem para armazenar informa√ß√µes que devem persistir enquanto a tela n√£o for fechada ou atualizada. √â o filtro selecionado, o item da lista destacado, o carrinho de compras, tudo isso e mais!

O Estado de um componente React talvez seja a pe√ßa mais essencial para o seu funcionamento. Enquanto, numa aplica√ß√£o JavaScript sem uso de bibliotecas, tais informa√ß√µes ficariam, muito provavelmente, espalhadas e desorganizadas, no React, cada componente cuida das suas informa√ß√µes, e o React garante que todas estejam atualizadas de maneira otimizada.

Mas, antes de nos aprofundarmos em como usamos o Estado de um componente, vamos dar um passo atr√°s e falar de Eventos!

--- Introdu√ß√£o aos eventos ---

<!-- v√≠deo componentes com estado e eventos: introdu√ß√£o ao eventos -->

Eventos no React s√£o como os eventListeners do JavaScript: voc√™ os associa aos elementos que exibir√° na tela, e eles nortear√£o como cada componente reage a uma a√ß√£o de quem usa.

<!-- import React from 'react';
import './App.css';

/* Embora isso funcione, essa DEFINITIVAMENTE
n√£o √© a maneira correta de se criar eventos
em React! A fun√ß√£o se refere ao componente,
ent√£o deve ser parte de sua classe! */
function handleClick() {
  console.log('Clicou no bot√£o!')
}

class App extends React.Component {
  /* Repare que, diferentemente do HTML, no
  JSX voc√™ associa uma fun√ß√£o a um evento
  passando a pr√≥pria fun√ß√£o entre chaves `{}` */
  render() {
    return <button onClick={handleClick}>Meu bot√£o</button>
  }
}

export default App; -->

-- Para fixar --

Crie uma aplica√ß√£o React com npx create-react-app fancy-buttons, que atenda ao seguinte crit√©rios: O componente App.js deve ser alterado para que seja um componente de classe e contenha um bot√£o associado a um evento que imprime um texto qualquer via console.log().

‚ö† N√£o se preocupe com a sintaxe correta para fun√ß√µes de eventos por enquanto.

Fa√ßa com que sua aplica√ß√£o anterior exiba tr√™s bot√µes lado a lado com textos diferentes. Cada bot√£o clicado deve acionar um evento diferente, cada um escrevendo algo diferente no console do navegador via console.log().

--- Vinculando fun√ß√µes √† classe com this e bind no constructor ---

<!-- v√≠deo sobre Componentes com estado e eventos: constructors, this e fun√ß√µes de evento no lugar certo -->

Vamos por partes, porque esse v√≠deo trouxe muita informa√ß√£o!

--- Acessando uma fun√ß√£o nossa dentro da classe ---

Para acessar uma fun√ß√£o que criamos dentro de uma classe, em um eventListener, precisamos explicitar a origem de nossa fun√ß√£o com a sintaxe this.minhaFuncao.

<!-- import React from 'react';
import './App.css';

class App extends React.Component {
  handleClick() {
    console.log('Clicou!')
  }

  render() {
    /* No React, precisamos dizer explicitamente que queremos uma fun√ß√£o da nossa classe
    atrav√©s da sintaxe `this.minhaFuncao` para us√°-la num evento */
    return <button type="button" onClick={this.handleClick}>Meu bot√£o</button>;
  }
}

export default App; -->

--- Constructor ---

Toda classe em JavaScript tem acesso a um m√©todo chamado constructor(), e, com as classes de React, definidas com class MinhaClasse extends React.Component, n√£o √© diferente! Quando um componente React √© criado, ou seja, quando √© colocado na tela do navegador, a primeira coisa que √© executada √© a fun√ß√£o constructor(). Toda a l√≥gica interna que o React adiciona aos seus componentes come√ßa a ser inclu√≠da neles nesse momento.

No JavaScript, o super() refere-se ao construtor da classe pai. (No nosso caso, refere-se √† implementa√ß√£o de React.Component.) √â importante lembrar que voc√™ n√£o pode usar o this em um construtor at√© que voc√™ tenha chamado o construtor da classe pai, pois o JavaScript n√£o vai te deixar fazer isso. Ent√£o, por ora, apenas se lembre de que, para usar o this dentro do constructor(), √© preciso chamar o super() antes. Ter isso em mente vai ser muito importante ao lidar com estados nas classes!

A grande quest√£o, no entanto, √© que √© poss√≠vel adicionar aos construtores das classes React comportamentos e l√≥gica extras! Fazemos assim:

import React from 'react';
import './App.css';

<!-- class App extends React.Component {
  constructor(props) {
    // A fun√ß√£o `super()` √© chamada para garantir que a l√≥gica interna do React rode **antes** da sua. Se n√£o for assim, o c√≥digo n√£o funcionar√°
    super()

    // Sua l√≥gica extra vai aqui! O par√¢metro `props` √© opcional, para voc√™ acessar as props diretamente no construtor
  }

  render() {
    return <span>Meu componente!</span>
  }
}

export default App; -->

Conhecer o construtor √© uma pe√ßa fundamental para usarmos Eventos e Estados nos componentes do React com classes!

--- this ---

O this acessa, nos componentes React, um objeto que guarda tudo que importa √†quele componente. Um c√≥digo de Hello, World! em React, ilustrado abaixo, gera a impress√£o no console a seguir:

<!-- import React from 'react';
import './App.css';

class App extends React.Component {
  render() {
    console.log(this)
    return <span>Hello, world!</span>
  }
}

export default App; -->

<!-- App {
  context: {}
  props: {}
  refs: {}
  state: null
  updater: { isMounted: ∆í, enqueueSetState: ∆í, enqueueReplaceState: ∆í, enqueueForceUpdate: ∆í }
  _reactInternalFiber: FiberNode { tag: 1, key: null, stateNode: App, elementType: ∆í, type: ∆í, ‚Ä¶}
  _reactInternalInstance: {_processChildContext: ∆í}
  isMounted: (...)
  replaceState: (...)
  __proto__: Component
    constructor: class App
    isMounted: (...)
    render: ∆í render()
    replaceState: (...)
    __proto__: {...}
  // ... Continua
  } -->

Como se pode ver, o this, dentro das classes de componentes React, √© um objeto enorme que cont√©m, basicamente, tudo o que concerne √†quele componente dentro da aplica√ß√£o. Quando fazemos this.props, estamos acessando a chave props dentro do objeto this, que ir√° conter as propriedades (props vem de propriedades!) passadas √†quele componente. Com ele, por exemplo, conseguimos acessar as props e outras coisas, como o estado do componente, dentro das fun√ß√µes render e constructor, para dar dois exemplos.

Mas qual √©, ent√£o, o grande problema do this? Quando definimos fun√ß√µes nossas em uma classe de componente React, ele n√£o funciona t√£o bem! Veja s√≥:

<!-- import React from 'react';
import './App.css';

class App extends React.Component {
  handleClick() {
    // Essa chamada ao `this` retorna `undefined`? !
    console.log(this)
    console.log('Clicou')
  }

  render() {
    // J√° essa chamada ao `this`, feita de dentro da fun√ß√£o `render`, retorna o objeto que esperamos
    console.log(this)
    return <button onClick={this.handleClick}>Meu bot√£o</button>
  }
}

export default App; -->

üí° Execute os exemplos localmente para ver com seus pr√≥prios olhos e digitar com seus pr√≥prios dedos as particularidades de React!

Esse comportamento acontece, em resumo, em fun√ß√£o de dificuldades que o JavaScript tem com a implementa√ß√£o de uma l√≥gica de classes, l√≥gica para qual a linguagem n√£o foi feita!. A solu√ß√£o √©, no constructor, fazermos, para cada uma de nossas fun√ß√µes, um v√≠nculo ‚Äúmanual‚Äù da nossa fun√ß√£o com o this.

<!-- import React from 'react';
import './App.css';

class App extends React.Component {
  constructor() {
    super()
    // A fun√ß√£o abaixo vincula "manualmente" o `this` √† nossa fun√ß√£o
    this.handleClick = this.handleClick.bind(this)
  }

  handleClick() {
    /* Agora esse log retorna o objeto `this`, j√° acess√≠vel para nossa fun√ß√£o!
    Com isso, podemos acessar as `props`, estado do componente (ainda vamos ver como!)
    e tudo o mais daqui de dentro */
    console.log(this)
    console.log('Clicou!')
  }

  render() {
    return <button onClick={this.handleClick}>Meu bot√£o</button>
  }
}

export default App; -->

üí° Ao definir uma fun√ß√£o da classe com uma arrow function, com a sintaxe minhaFuncao = () => {...}, voc√™ n√£o precisar√° fazer o bind. Ent√£o n√£o precisaremos do construtor nesse caso. Veja como o exemplo acima seria feito com arrow function:

<!-- import React from 'react';
import './App.css';

class App extends React.Component {
  handleClick = () => {
    console.log('Clicou!')
  }

  render() {
    return <button onClick={this.handleClick}>Meu bot√£o</button>
  }
}

export default App; -->

Se quiser ler mais a respeito, busque o texto ‚ÄúBinding vs arrow-function (for react onClick event)‚Äù nos Recursos Adicionais! E voc√™ pode usar qualquer uma das duas sem problemas, o importante aqui √© saber que existem as duas formas - fa√ßa como se sentir mais √† vontade! üòÉ

--- Para fixar ---

- Utilizando o mesmo c√≥digo do exerc√≠cio anterior, declare dentro da classe <App> as fun√ß√µes que, anteriormente, foram declaradas fora da classe.

- Fa√ßa com que as fun√ß√µes criadas no exerc√≠cio anterior possuam acesso ao objeto this.

--- Unindo componentes com estados e eventos ---

<!-- V√≠deo sobre Componentes com estado e eventos: juntando tudo -->

Agora que aprendemos sobre this e sobre como lidar com eventos dentro das classes React.

Vamos acessar o estado de um componente React! Veja o exemplo abaixo para conhecer a sintaxe:

<!-- import React from 'react';
import './App.css';

class App extends React.Component {
  constructor() {
    super();
    /* Para definir um estado inicial ao componente, a ser definido
    no momento em que o componente for colocado na tela, fa√ßa uma atribui√ß√£o
    de um objeto √† chave `state` do `this`, ou seja, ao `this.state` */
    this.state = {
      numeroDeCliques: 0,
    };
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    /* Voc√™ **NUNCA** deve fazer atribui√ß√µes diretamente a `this.state`. Deve,
    ao inv√©s disso, SEMPRE utilizar a fun√ß√£o `this.setState(novoEstado)` do
    React */
    this.setState({
      numeroDeCliques: 1,
    });
  }
  render() {
    /* Para LER o estado, voc√™ pode usar `this.state.chaveDoMeuEstado` */
    const { numeroDeCliques } = this.state;
    return (
      <button
        type="button"
        onClick={ this.handleClick }
      >
        { numeroDeCliques }
      </button>
    );
  }
}
export default App; -->

E muita aten√ß√£o ao que foi dito acima! Voc√™ NUNCA deve atribuir valores ao estado diretamente com this.state. O estado √© atualizado de forma ass√≠ncrona pelo React, para garantir performance, e o React n√£o garante a ordem em que as atualiza√ß√µes ocorrer√£o. Se voc√™ fizer uma atribui√ß√£o direta, ter√° problemas! Fa√ßa-o sempre atrav√©s da fun√ß√£o this.setState(meuNovoObjetoQueRepresentaOEstado). N√ÉO se esque√ßa disso! üòÉ

Mas se a a atualiza√ß√£o do estado n√£o ocorre em ordem, voc√™s perguntam, ‚Äúcomo eu atualizo meu estado com base no estado anterior? Se tudo ocorre fora de ordem, como eu sei que uma conta de novoEstado = estadoAtual + 1 n√£o dar√° problemas?‚Äù

Pois bem! Lembre-se de que, com Promises, para garantir que algum c√≥digo executasse somente ap√≥s o retorno da Promise, que √© ass√≠ncrona, voc√™ tinha que coloc√°-lo dentro da fun√ß√£o .then. Aqui a l√≥gica √© da mesma natureza:

<!-- import React from 'react';
import './App.css';

class App extends React.Component {
  constructor() {
    super();
    this.state = {
      numeroDeCliques: 0,
    };
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    /* Passando uma callback √† fun√ß√£o setState, que recebe de par√¢metros
    o estado anterior e as props do componente, voc√™ garante que as atualiza√ß√µes
    do estado acontecer√£o uma depois da outra! */
    this.setState((estadoAnterior, _props) => ({
      numeroDeCliques: estadoAnterior.numeroDeCliques + 1,
    }));
  }

  render() {
    const { numeroDeCliques } = this.state;
    return (
      <button
        type="button"
        onClick={ this.handleClick }
      >
        { numeroDeCliques }
      </button>
    );
  }
}

export default App; -->

--- Definindo o estado inicial atrav√©s de Public Class Fields ---

At√© agora vimos que podemos definir o estado inicial atrav√©s do constructor. Uma outra maneira de definir o estado inicial de seus componentes √© utilizando a sintaxe Public Class Fields. √â uma forma mais simples e menos verbosa de definirmos nosso estado. Utilizando essa sintaxe, podemos fazer esta declara√ß√£o fora de nosso constructor. Vamos ver nosso exemplo acima com essa sintaxe:

<!-- import React from 'react';
import './App.css';

class App extends React.Component {
  constructor() {
    super();
    // Removemos a declara√ß√£o do estado de dentro do construtor
    // this.state = {
    //   numeroDeCliques: 0,
    // };

    this.handleClick = this.handleClick.bind(this);
  }

  // Fazemos a defini√ß√£o do estado utilizando a sintaxe Public Class Field
  state = {
    numeroDeCliques: 0,
  };

  handleClick() {
    this.setState((estadoAnterior, _props) => ({
      numeroDeCliques: estadoAnterior.numeroDeCliques + 1,
    }));
  }

  render() {
    const { numeroDeCliques } = this.state;
    return (
      <button type="button" onClick={ this.handleClick }>
        { numeroDeCliques }
      </button>
    );
  }
}

export default App; -->

Sinta-se livre para escolher qualquer uma dessas formas para definir seu estado! O importante √© que voc√™ entenda seu funcionamento e sua utiliza√ß√£o.

üí° Se voc√™ quisesse chamar, no elemento, um evento passando um par√¢metro, voc√™ deveria trocar a sintaxe <button onClick{this.minhaFuncao} ...> por <button onClick={() => this.minhaFuncao('meu parametro')}. Basicamente, substitua a fun√ß√£o do evento por uma chamada √† mesma feita via callback! Experimente!

--- Para fixar ---
 - Agora voc√™ vai converter a aplica√ß√£o desenvolvida nos exerc√≠cios anteriores para uma que conta o n√∫mero de cliques dados em cada bot√£o!
Defina um estado inicial para a contagem de cada bot√£o.

üëÄ De olho na dica: lembre-se que voc√™ pode definir tr√™s chaves, uma para cada bot√£o!

Agora, quando um bot√£o for clicado, altere de forma ass√≠ncrona o estado deste bot√£o de zero para um.

Por fim, incremente a contagem de um bot√£o sempre que ele for clicado.

--- State vs Props ---
Voc√™ pode entender a diferen√ßa props vs state da seguinte forma:

- props s√£o uma forma de passar dados de pai para filho.
- state √© reservado para dados que seu componente controla.

O conceito √©: state, ou estado do componente, deve servir para guardar valores do Componente que mudam com o uso dele. As props s√£o valores fixos que um componente recebe e n√£o altera.

Pelos princ√≠pios do React, voc√™ nunca deve tentar alterar o que um componente recebe como props, como no exemplo abaixo:

<!-- this.props.name = 'novo nome'; -->

------------------ Em resumo ------------------

Vamos recapitular? Hoje, no conte√∫do, come√ßamos a desenvolver as seguintes habilidades:

- Ler o estado de um componente e us√°-lo para alterar o que exibimos no browser;
- Inicializar um componente, dando a ele um estado pr√©-definido;
- Atualizar o estado de um componente;
- Capturar eventos utilizando a sintaxe do React.

Para isso, estudamos, no conte√∫do, os seguintes pontos:

- Todo componente possui seu pr√≥prio estado e tem 100% de controle sobre ele;
- Quando um componente √© colocado na tela, ele executa uma fun√ß√£o chamada constructor, e, usando a linha super(), podemos sobrescrev√™-la para estender seu comportamento;
- O objeto this, acess√≠vel a toda classe de componente React, cont√©m tudo o que concerne √†quele componente e deve ser vinculado explicitamente √†s fun√ß√µes criadas dentro da classe, por meio da sintaxe this.minhaFuncao = this.minhaFuncao.bind(this) no construtor do componente;
-Fun√ß√µes que tratam eventos devem ser vinculadas aos seus respectivos elementos com {this.minhaFuncao} ou {() => this.minhaFuncao('Meu parametro')};
- √â poss√≠vel ler o estado de um componente via this.state, √© poss√≠vel definir um estado inicial no construtor com uma atribui√ß√£o a this.state, e deve-se atualizar tal estado somente com a fun√ß√£o this.setState;
- A atualiza√ß√£o do estado √© ass√≠ncrona e, por isso, se voc√™ quiser garantir que uma atualiza√ß√£o ocorrer√° depois da outra, tal atualiza√ß√£o dever√° ser definida via callback passada √† fun√ß√£o this.setState, no formato this.setState((estadoAnterior, props) => novoEstado)

--- Para fixar ---
- Defina uma l√≥gica que estabele√ßa que, quando o n√∫mero de cliques no bot√£o for par, ele deve ser verde.

- Agora, ao clicar no bot√£o, a sua cor atual deve ser impressa por meio de um console.log(). Essa l√≥gica precisa ser implementada na mesma fun√ß√£o utilizada para aumentar o contador de cliques dos bot√µes.

üëÄ De olho na dica: lembre-se de substituir a refer√™ncia √† fun√ß√£o, no evento, por uma callback que invoca!