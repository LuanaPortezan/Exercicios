----------- Conceitos sobre roteamento -------- 

-- Single Page Application -- 

Antes de come√ßar a falar sobre React Router, √© preciso entender um tipo de aplica√ß√£o chamado Single Page Application (SPA), haja visto que aplica√ß√µes em React Router s√£o SPAs. Logo, assista a este v√≠deo, que explica o conceito e o funcionamento de uma SPA:

<!-- v√≠deo -->

--- props.children ---

Children √© uma √≥tima ferramenta para reutiliza√ß√£o de componentes. A utiliza√ß√£o √© bem simples, veja abaixo:

<!-- class App extends Component {
  render() {
    return (
      <div className='main'>
        <ComponentePai>
          <p>SUPIMPA</p>
        </ComponentePai>
      </div>
    )
  }
} -->

E dessa forma podemos acessar e exibir na tela o valor SUPIMPA no ComponentePai:

<!-- const ComponentePai = (props) => {
  return (
    <div>
      {props.children}
    </div>
  )
} -->

Nesse exemplo utilizamos uma tag p, mas note que poderia ser um ou v√°rios elementos de qualquer natureza, seja uma tag, ou at√© um componente. Ainda sim, ela √© acessada da mesma forma dentro de ComponentePai. √â importante perceber que, no caso acima, props.children √© um objeto por ser apenas um elemento. Caso o ComponentePai esteja com mais de um elemento dentro como no exemplo abaixo, props.children se torna um array de objetos, com as informa√ß√µes de cada filho.

<!-- class App extends Component {
  render() {
    return (
      <div className='main'>
        <ComponentePai>
          <p>SUPIMPA</p>
          <h1>BACANA</h1>
          <span>INCR√çVEL</span>
        </ComponentePai>
      </div>
    )
  }
} -->

--- Instala√ß√£o React Router Dom ---

Para poder fazer uso de React Router, √© preciso que se instale em uma aplica√ß√£o React o pacote react-router-dom:

<!-- npm install react-router-dom@v5 -->

Recentemente foi lan√ßada uma atualiza√ß√£o para o pacote react-router-dom que trouxe breaking changes, ou seja, mudan√ßas que n√£o s√£o compat√≠veis com as vers√µes anteriores. Por isso √© importante que voc√™ instale o react-router-dom na vers√£o especificada acima, para que os exemplos da aula funcionem corretamente.

--- Componentes BrowserRouter e Route ---

Agora, assista a este v√≠deo, que fala a respeito dos componentes BrowserRouter e Route e sobre como fazer uso deles em conjunto:

<!-- v√≠deo -->

--- O componente BrowserRouter ---

BrowserRouter √© o componente que encapsula a sua aplica√ß√£o, de forma a te possibilitar fazer uso de navega√ß√£o.

Voc√™ pode encapsular os componentes diretamente no App.js:

<!-- // ./src/App.js
import { BrowserRouter } from 'react-router-dom';
// ...
<BrowserRouter>
  <Home />
  <About />
</BrowserRouter>
// ... -->

Outra forma √© encapsulando o pr√≥prio componente <App />, no arquivo index.js. Assim, todos os componentes renderizados por App poder√£o fazer uso da navega√ß√£o:

<!-- // ./src/index.js
import { BrowserRouter } from 'react-router-dom';
// ...
<BrowserRouter>
  <App />
</BrowserRouter>
// ... -->

--- O componente Route ---

Route √© o componente fundamental em React Router, que estabelece o mapeamento entre o caminho de URL declarado com o componente. Tal mapeamento, no que diz respeito √† correspond√™ncia entre o caminho da URL atual e a presente no componente, pode ser feito das seguintes formas, ilustradas pelos seguintes exemplos:

- O caminho da URL atual do navegador come√ßa com o caminho /about, declarado na prop path no componente Route. Dessa forma, se o caminho da URL for /about, o componente About ser√° renderizado:

<!-- <Route path="/about" component={ About } /> -->

Entretanto, se a URL atual for /about/me, por exemplo, tamb√©m existir√° correspond√™ncia, e o componente About continuar√° sendo renderizado. Nesse caso, o par√¢metro exact pode entrar em a√ß√£o:

<!-- <Route exact path="/about" component={ About } /> -->

Se houver uma correspond√™ncia exata entre o caminho da URL atual e o caminho /about declarado em Route, o componente ser√° renderizado. Por outro lado, se o caminho da URL atual for /about/me, n√£o haver√° correspond√™ncia exata, logo o componente About n√£o ser√° renderizado.

- Outra maneira de renderiza√ß√£o de componente com Route √© fazendo uso do elemento children. Ou seja, se o seu c√≥digo estiver assim: <Route path="/about" component={About} />, voc√™ tamb√©m poder√° fazer da seguinte forma:

<!--   <Route path="/about" >
    <About />
  </Route> -->

--- Componentes renderizados ---

Se houver v√°rios componentes apresentando correspond√™ncia entre seu caminho de URL e o caminho atual da aplica√ß√£o, todos os componentes apresentando correspond√™ncia ser√£o renderizados. Ou seja, suponha que houvesse a seguinte lista de componentes do tipo Route:

<!-- <Route path="/about" component={ About } />
<Route path="/contact" component={ Contact } />
<Route path="/" component={ Home } /> -->

Se o caminho atual da URL da aplica√ß√£o for /, todos esses componentes ser√£o renderizados, haja vista que nenhuma rota faz correspond√™ncia exata entre o caminho da URL, definido via prop path. Assim, path="/" faz correspond√™ncia com qualquer caminho de URL.

Agora, se o caminho atual da URL da aplica√ß√£o for /contact, os componentes Contact e Home ser√£o renderizados. Isso pode ser um problema, e uma forma de atac√°-lo √© organizar essas rotas via componente Switch, que voc√™ ver√° com mais detalhes em instantes. üòâ

--- Componente Link ---

Veja o v√≠deo abaixo onde o Link √© utilizado e que mostra como a navega√ß√£o funciona por meio do React Router:

<!-- v√≠deo -->

No v√≠deo acima, vimos que Link √© o componente a ser usado no lugar de elementos com a tag a, de forma a disponibilizar navega√ß√£o por URL na sua aplica√ß√£o SPA sem o recarregamento de p√°gina que a tag a exige. Ou seja, se voc√™ quiser definir um link que leve quem usa sua aplica√ß√£o para a URL com o caminho /about, voc√™ poderia chamar o componente Link da seguinte forma:

<!-- <Link to="/about" > About </Link> -->

E lembre-se: palavras, imagens, at√© mesmo outros componentes podem ser componentes filhos do Link! Ser filho do Link significa que, se voc√™ clicar neste filho, ir√° para onde o Link te direciona!

--- Componentes Route com passagem de props ---

Assista a este v√≠deo, que fala a respeito de como fazer uso de par√¢metros de URL em componentes do tipo Route:

<!-- v√≠deo -->

Sobre o componente Route, podemos aprender:

- No que diz respeito ao componente Route, voc√™ pode associar um componente com o caminho da URL via children, component ou render;

- Faz-se uso da prop component de Route quando n√£o √© necess√°rio passar informa√ß√µes adicionais via props para o componente a ser mapeado. Ou seja, se voc√™ tem um componente About que n√£o precisa de props setadas para ser chamado, e voc√™ precisa mape√°-lo para o caminho de URL /about, voc√™ poderia criar uma rota da seguinte forma: <Route path="/about" component={About} />;

- J√° a prop render de Route √© usada quando √© necess√°rio passar informa√ß√µes adicionais via props para o componente a ser mapeado. Ou seja, se voc√™ tem um componente Movies que precisa receber uma lista de filmes via props movies, e voc√™ precisa mape√°-lo para o caminho de URL /movies, voc√™ poderia criar uma rota da seguinte forma: <Route path="/movies" render={(props) => <Movies {...props} movies={['Cars', 'Toy Story', 'The Hobbit']} />} />;

- Tanto component quanto render permitem que voc√™ tenha acesso a informa√ß√µes de rota (match, location e history) via props do componente que voc√™ est√° mapeando. Ou seja, se voc√™ tem a rota <Route path="/about" component={About} />, About ter√° match, location e history setadas via props.

--- Componentes Route com passagem de par√¢metro (rotas din√¢micas) ---

O interessante em rotas din√¢micas √© que podemos utilizar o mesmo componente para renderizar v√°rios caminhos diferentes. Para fazer uso de par√¢metro de URL em Route, √© preciso fazer uso da sintaxe :nome_do_parametro dentro da propriedade path. Ou seja, <Route path="/movies/:movieId" component={Movie} /> vai definir um par√¢metro chamado movieID, e o componente Movie √© mapeado a qualquer um dos seguintes caminhos de URL:

- /movies/1;
- /movies/2;
- /movies/thor.

--- Componente Switch ---

O componente Switch √© usado para encapsular um conjunto de rotas que s√£o definidas via Route, conforme podemos observar na imagem abaixo:

<!-- Imagem -->

Dada a URL atual da aplica√ß√£o, o Switch procura de cima para baixo pelo primeiro Route que possuir correspond√™ncia entre seu caminho definido na prop path do componente e a URL atual da aplica√ß√£o. Ou seja, se tivermos um Switch com as rotas abaixo:

<!-- <Switch>
  <Route path="/about" component={About} />
  <Route path="/contact" component={Contact} />
  <Route path="/movies" component={Movies} />
  <Route path="/" component={Home} />
</Switch> -->

Ao mudarmos a URL da aplica√ß√£o para que seu caminho seja /contact, somente o componente Contact ser√° renderizado.

Todos os filhos de um Switch devem ser Route ou Redirect. Apenas o primeiro filho que corresponder ao local atual ser√° renderizado. Se n√£o houvesse o Switch mais de um componente poderia ser renderizado na mesma rota de forma errada.

Em uma compara√ß√£o direta, √© como o switch case do javascript:

√â apenas uma compara√ß√£o, n√£o utilize o exemplo abaixo

<!--   switch (rota) {
    case '/about':
      return <About />;
    case '/contact':
      return <Contact />;
    case '/movies':
      return <Movies />;
    default:
      return <Home />
  } -->

--- Componente Redirect ---

Conforme o pr√≥prio nome diz, Redirect √© um componente que permite ativamente levar quem usa a aplica√ß√£o para diferentes locais dela. Um caso de uso bastante comum de Redirect √© autentica√ß√£o: a pessoa s√≥ pode acessar informa√ß√µes sens√≠veis (tipo conta banc√°ria) de uma aplica√ß√£o se ela j√° estiver autenticada; caso contr√°rio, ela √© redirecionada para uma p√°gina de login. Veja um exemplo de utiliza√ß√£o abaixo:

<!-- <Switch>
    <Route path="/dashboard" component={Dashboard} />
    <Route exact path="/">
      {logado ? <Redirect to="/dashboard" /> : <Login />}
    </Route>
  </Switch> -->

  Caso a aplica√ß√£o tenha o caminho / ser√° feita uma verifica√ß√£o na vari√°vel logado, no caso de true a p√°gina ser√° redirecionada para o caminho /dashboard e ent√£o renderizar√° o componente Dashboard, caso contr√°rio, renderizar√° o componente Login.

D√™ sempre prioridade para a utiliza√ß√£o de Redirect para redirecionar, uma vez que, ele √© criado para isso.

Para que voc√™ tenha um pouco mais de contexto, observe a imagem abaixo que compara o Link e o Redirect:

<!-- imagem -->

--- Utilizando o history.push() ---

Uma outra forma de alternarmos entre as rotas da nossa aplica√ß√£o √© utilizando outra fun√ß√£o do react-router-dom, o history.push. Quando chamada, ela altera a rota da p√°gina de acordo com o que passarmos como par√¢metro.

O history √© um objeto que possui o hist√≥rico contendo diversas informa√ß√µes das rotas que utilizamos na aplica√ß√£o. Podemos acess√°-lo por meio das props dos nossos componentes. Executando a fun√ß√£o history.push('/nome-da-rota') podemos direcionar a pessoa usu√°ria para qualquer rota que desejarmos.

Vamos entender o funcionamento do history.push na pr√°tica! Crie uma nova aplica√ß√£o React com o comando npx create-react-app exemplo-history e instale o Router com o comando npm install react-router-dom@v5.

Crie um diret√≥rio pages com dois arquivos:

- Home.jsx

<!-- import React from 'react';

class Home extends React.Component {
  render() {
    return (
      <h1>Home Page</h1>
    );
  }
}

export default Home;
 -->

- Welcome.jsx

<!-- import React from 'react';

class Welcome extends React.Component {
  render() {
    return (
      <h1>Boas vindas</h1>
    );
  }
}

export default Welcome;
 -->

 Por fim, modifique o componente <App /> para que fique assim:

 <!-- import React from 'react';
import { BrowserRouter, Route, Switch } from 'react-router-dom';
import Welcome from './pages/Welcome';
import Home from './pages/Home';

class App extends React.Component {
  render() {
    return (
      <BrowserRouter>
        <Switch>
          <Route exact path="/" component={ Home } />
          <Route path="/welcome" component={ Welcome } />
        </Switch>
      </BrowserRouter>
    );
  }
}

export default App;
 -->

 Essa √© uma aplica√ß√£o simples contendo duas p√°ginas. Agora vamos criar um bot√£o na p√°gina Home que far√° com que a pessoa usu√°ria, ao clicar nesse bot√£o, seja direcionada para a p√°gina /welcome. Para isso, utilizaremos o history.push.

 <!-- import React from 'react';

class Home extends React.Component {
  render() {
    const { history } = this.props;
    return (
      <>
        <h1>Home Page</h1>
        <button
          type="button"
          onClick={ () => history.push('/welcome') }
        >
          Acesse a p√°gina de Boas-Vindas
        </button>
      </>
    );
  }
}

export default Home;
 -->

 Passando o par√¢metro /welcome ao history.push() far√° com que, ao ser clicado, o bot√£o direcione a pessoa usu√°ria para a p√°gina welcome.

Uma das vantagens de se utilizar essa fun√ß√£o √© que, com ela, √© poss√≠vel transferirmos informa√ß√µes entre as rotas. Por exemplo, poder√≠amos transferir as informa√ß√µes do estado de um componente para outro. Para isso, basta adicionarmos um segundo par√¢metro √† fun√ß√£o.

Mas aten√ß√£o aqui: se voc√™ estiver usando muito a estrat√©gia de ‚Äúpassar informa√ß√µes‚Äù no segundo argumento do history.push, isso pode ser sinal de que sua aplica√ß√£o n√£o est√° bem estruturada. Uma estrat√©gia melhor talvez seja a de elevar o estado.

Mas vamos ao exemplo.

<!-- import React from 'react';

class Home extends React.Component {
  constructor() {
    super();
    this.state = {
      userName: 'Tryber',
      role: 'Admin',
    };
  }

  render() {
    const { history } = this.props;
    return (
      <>
        <h1>Home Page</h1>
        <button
          type="button"
          onClick={ () => history.push('/welcome', this.state) }
        >
          Acesse a p√°gina de Boas-Vindas
        </button>
      </>
    );
  }
}

export default Home;
 -->

 Dessa forma, ao clicar no bot√£o, a pessoa usu√°ria ser√° direcionada para a p√°gina /welcome e, ainda, teremos acesso ao this.state do componente Home.

Para acessar esse valor no componente Welcome, podemos buscar a chave location.state, do history.

<!-- import React from 'react';

class Welcome extends React.Component {
  render() {
    const { history } = this.props;
    const { location } = history;
    return (
      <>
        <h1>Boas vindas,</h1>
        <h2>
          {
            location.state ? location.state.userName : 'Pessoa desconhecida'
          }
        </h2>
        <button
          type="button"
          onClick={ () => console.log(history) }
        >
          History
        </button>
      </>
    );
  }
}

export default Welcome;
 -->

 No exemplo acima, o componente busca a chave location.state do history. Se essa chave possuir algum valor, ele ir√° renderizar location.state.userName, que √© um valor presente no estado do componente Home.

Experimente remover o segundo par√¢metro do history.push() no componente Home. Se voc√™ fizer isso, ir√° reparar que o componente Welcome n√£o possuir√° a informa√ß√£o do estado do componente Home e ir√° renderizar Pessoa desconhecida.

O history possui diversas informa√ß√µes. Clique no bot√£o History contendo o console.log(history) e analise o seu console üëÄ.

Outra chave bastante utilizada do history √© location.pathname. Essa chave ir√° retornar a rota que a pessoa usu√°ria est√° acessando. No exemplo acima, altere o c√≥digo do bot√£o para console.log(location.pathname) e veja o retorno no seu console. Essa informa√ß√£o pode ser muito valiosa para montar algumas l√≥gicas nas suas aplica√ß√µes üòâ.

--- Entendendo o fluxo dos componentes do React Router ---

Para deixar expl√≠cito o comportamento do React Router, deixamos o mapa mental a seguir. Use com modera√ß√£o. üòâ

<!-- imagem -->