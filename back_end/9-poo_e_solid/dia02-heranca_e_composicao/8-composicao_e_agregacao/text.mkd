Composi√ß√£o e Agrega√ß√£o
Composi√ß√£o
Para compreender a composi√ß√£o precisamos pensar no relacionamento entre objetos/classes. Por exemplo, na rede social uma conta tem perfil, tem foto e tem texto. Veja abaixo como ficaria em um diagrama.

diagrama-composicao
Na imagem acima, √© poss√≠vel notar que perfil, foto e texto est√£o contidos em conta da rede social, ou seja, estabelece-se uma rela√ß√£o de depend√™ncia que se voc√™ remover a classe principal (conta) a classe secund√°ria (perfil) deixar√° de fazer sentido, pois √© necess√°rio que seu perfil esteja vinculado a uma conta.

Portanto, o segredo para entender se existe rela√ß√£o entre duas classes √© se perguntar:

‚ÄúA classe Secund√°ria (perfil) est√° contida na classe Principal (conta)?‚Äù.

Se a resposta for sim, voc√™ tem uma composi√ß√£o. üéâ

Anota a√≠ üñä: A composi√ß√£o de objetos/classes √© uma forma de combinar objetos ou tipos de dados para construir sua estrutura.

Agora voc√™ deve estar se perguntando:

ü§î Qual a diferen√ßa entre composi√ß√£o e heran√ßa?

A heran√ßa tem por caracter√≠stica obter todas as propriedades da classe principal. Com isso, voc√™ obt√©m todos os atributos e m√©todos, deixando a classe secund√°ria mais especializada e espec√≠fica. Isso quer dizer que se voc√™ precisar alterar algo na classe principal voc√™ vai refletir isso na sua classe secund√°ria.

Por outro lado, a composi√ß√£o permite que voc√™ realize altera√ß√µes na classe principal sem afetar as demais envolvidas ou correr o risco de comprometer algum comportamento.

Veja um exemplo no c√≥digo abaixo e acompanhe a explica√ß√£o.

Copiar
class Profile {
  private name: string;
  private email: string;

  public setName(name: string) {
    this.name = name;
  }

  public setEmail(email: string) {
    this.email = email;
  }

  public toString(): string {
    return `name - [${this.name}] - email - [${this.email}]`;
  }
}

class SocialMediaAccount {
  // Cria nossa composi√ß√£o com o perfil
  private profile = new Profile();

  public editProfile(name: string, email: string) {
    this.profile.setName(name);
    this.profile.setEmail(email);
  }

  public printProfile() {
    console.log(this.profile.toString());
  }
}

const socialMediaAccount = new SocialMediaAccount();
socialMediaAccount.editProfile('Manuella', 'manu@trybe.com');
socialMediaAccount.printProfile();
No c√≥digo acima, voc√™ possui a classe Profile que possui os m√©todos respons√°veis por atualizar o nome e email do perfil. Em seguida, temos uma classe SocialMediaAccount que vai instanciar a classe Profile e ser utilizada no m√©todo editProfile para voc√™ editar o nome e email na respectiva conta da rede social. A a√ß√£o de utilizarmos a classe do perfil (Profile) para compor a classe de conta da rede social (SocialMediaAccount) √© conhecida por composi√ß√£o.

Dessa forma, voc√™ tem a liberdade de realizar as altera√ß√µes necess√°rias na classe principal(SocialMediaAccount) que n√£o vai afetar diretamente a classe secund√°ria (Profile). Al√©m disso, note que se voc√™ remover a classe SocialMediaAccount o perfil da pessoa vai perder o sentido, pois um perfil obrigatoriamente precisa estar vinculado a uma conta. Conclu√≠mos assim que Profile tem depend√™ncia da exist√™ncia de uma conta na rede social.

O v√≠deo abaixo mostra o uso da composi√ß√£o.

Bora dar uma olhada?


Agrega√ß√£o
Na agrega√ß√£o precisamos pensar no relacionamento entre objetos/classes, assim como na composi√ß√£o. No entanto √© um relacionamento que far√° parte e n√£o obrigatoriamente depender√° de outro objeto/classe para continuar existindo.

Veja esse conceito sendo aplicado no c√≥digo abaixo:

Copiar
class Friend {
  private nickname: string;

  public getNickname(): string {
    return this.nickname;
  }

  public setNickname(nickname: string) {
    this.nickname = nickname;
  }
}

class SocialMediaAccount {
  private friends = new Array<Friend>();

  public addFriend(friend: Friend) {
    this.friends.push(friend);
  }

  public printFriends() {
    this.friends.map((friend) => console.log(friend));
  }
}

const socialMediaAccount = new SocialMediaAccount();

const friendCarol = new Friend();
friendCarol.setNickname('Carol');

const friendFernando = new Friend();
friendFernando.setNickname('Fernando');

socialMediaAccount.addFriend(friendCarol);
socialMediaAccount.addFriend(friendFernando);
socialMediaAccount.printFriends();
No c√≥digo acima, voc√™ possui a classe Friend que possui os m√©todos respons√°veis por atualizar o nickname de uma pessoa amiga. Em seguida, voc√™ tem uma classe SocialMediaAccount que possui um array de pessoas amigas e possui o m√©todo addFriend para adicionar novas pessoas amigas na respectiva conta da rede social. Por fim, voc√™ inst√¢ncia a classe SocialMediaAccount para representar uma conta e a classe Friend realizando a atualiza√ß√£o de cada nickname para representar as duas pessoas amigas que voc√™ gostaria de adicionar na conta.

Agora, note que se voc√™ remover a classe SocialMediaAccount a classe Friend vai continuar fazendo sentido, pois se voc√™ deletar uma conta da pessoa usu√°ria ainda ser√° poss√≠vel atualizar pessoas amigas ou essas pessoas amigas serem adicionadas em contas de outras pessoas usu√°rias.

Portanto, na agrega√ß√£o os objetos podem existir sem depender do outro objeto, por outro lado, na composi√ß√£o os objetos dependem da exist√™ncia do outro objeto.

Veja o v√≠deo a seguir para entender melhor a diferen√ßa entre Heran√ßa e Composi√ß√£o:


Bora praticar!?

Para fixar:
Crie uma interface Logger.

Logger deve possuir um m√©todo log, que recebe um par√¢metro do tipo string e n√£o retorna nada (void).

Crie uma classe ConsoleLogger que implementa Logger. Voc√™ deve imaginar como o m√©todo log deve ser implementado, n√©? üòÅ.

Crie uma classe ConsoleLogger2 igual √† classe anterior, apenas a t√≠tulo de exemplo.

No console.log dentro do m√©todo log, diferencie o ConsoleLogger2 do ConsoleLogger.

Crie uma interface Database.

Database deve possuir um atributo do tipo Logger.

Database deve possuir um m√©todo save, que recebe dois par√¢metros, key e value, ambos strings, e n√£o retorna nada (void).

Crie uma classe ExampleDatabase que implementa Database.

ExampleDatabase deve receber o Logger como par√¢metro do construtor, e possuir como valor padr√£o um ConsoleLogger.

Dentro do m√©todo save, chame a fun√ß√£o log do Logger passado para o database para fazer o log dos par√¢metros passados para a save.

Crie um objeto de cada um dos Loggers.

Crie tr√™s objetos da ExampleDatabase, cada um dos dois primeiros recebendo um dos Loggers, e o √∫ltimo n√£o recebendo nenhum.

Utilize todos eles para salvar um conte√∫do fict√≠cio.