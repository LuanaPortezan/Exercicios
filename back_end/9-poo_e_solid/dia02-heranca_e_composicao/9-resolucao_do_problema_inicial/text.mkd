Resolu√ß√£o do problema inicial
Lembra do probleminha que voc√™ parou para pensar em como resolver no come√ßo da aula? Acha que agora j√° tem uma ideia de como resolver?

Aqui vai uma sugest√£o de resolu√ß√£o, s√≥ para fixar o aprendizado. Leia com calma, e por uns bons minutos!

initial problem
Ilustra√ß√£o das classes e interface da aplica√ß√£o
Dada a quantidade expressiva de termos em ingl√™s, mais um dicion√°rio informal:

clause: cl√°usula
contract: contrato
describe: descrever
legal person: pessoa jur√≠dica
person: pessoa
natural person: pessoa f√≠sica
sale(s): venda(s)
sign: assinar
signatory/signatories: assinante, assinantes (do contrato)
subject: assunto (do contrato)
O c√≥digo para a resolu√ß√£o do problema est√° logo abaixo, mas antes, confira o motivo de usarmos interface e/ou classe (heran√ßa):

Interface Contract:

Ser√° o nosso contrato, algo que nos guiar√° em rela√ß√£o √†s regras de neg√≥cio;
√â importante ser utilizada quando sabemos quais atributos e/ou m√©todos devem ser utilizados e s√£o imprescind√≠veis para a implementa√ß√£o da nossa classe;
As interfaces n√£o necessariamente cont√™m todos os elementos que precisam ser implementados em uma classe. Contudo, elas funcionam como um guia para o cumprimento das regras de neg√≥cio. Ainda √© poss√≠vel definir m√©todos e atributos adicionais, ou ainda criar v√°rias interfaces, cada uma relacionada a regras espec√≠ficas, e implement√°-las em uma mesma classe;
No exemplo abordado, os atributos subject, clause, signatories e o m√©todo describe s√£o importantes para a regra em quest√£o e est√£o sendo implementados na classe SalesContract. Entretanto, al√©m desses elementos, outros m√©todos tamb√©m s√£o implementados. O que nos mostra, que por mais que venhamos a definir um contrato com elementos espec√≠ficos, ainda temos a flexibilidade de fazer ajustes e implementa√ß√µes.
Heran√ßa - classe Person:

Permite a reutiliza√ß√£o do c√≥digo, visto que todas as declara√ß√µes da classe m√£e (superclasse), com exce√ß√£o de elementos privados, s√£o herdadas;
Aumenta o acoplamento do c√≥digo, pois altera√ß√µes na implementa√ß√£o em uma superclasse podem afetar as suas subclasses. Por exemplo, a adi√ß√£o, remo√ß√£o ou altera√ß√£o de m√©todos e propriedades pode provocar bugs caso n√£o sejam planejadas com cautela;
No exemplo abordado, as classes NaturalPerson e LegalPerson herdam de Person. Observe que ambas as classes filhas mant√™m o padr√£o de receberem par√¢metro name e de reutilizar o m√©todo getter name. Este √© um exemplo reduzido, mas que nos mostra o quanto a heran√ßa pode ser √∫til.
Copiar
interface Contract {
  subject: string;
  clauses: string[];
  signatories: Person[];
  describe(): void;
}

class Person {
  private _name;
  constructor(name: string) {
    this._name = name;
  }
  get name() { return this._name; }
}

class NaturalPerson extends Person {
  private _cpf;
  constructor(name: string, cpf: string) {
    super(name);
    this._cpf = cpf;
  }
  get cpf() { return this._cpf; }
}

class LegalPerson extends Person {
  private _cnpj;
  constructor(name: string, cnpj: string) {
    super(name);
    this._cnpj = cnpj;
  }
}

class SalesContract implements Contract {
  private _signatories: Person[];
  private _clauses: string[];

  constructor() {
    this._signatories = [];
    this._clauses = [];
  }

  get signatories() { return [...this._signatories]; }
  get clauses() { return [...this._clauses]; }
  get subject() { return "Sales"; }

  sign(signatory: Person) { this._signatories.push(signatory); }
  addClause(clause: string) {
    if (this._signatories.length > 0) return;
    this._clauses.push(clause);
  }

  describe() {
    console.log('--------------------');
    console.log(`Contrato: ${this.subject}`);
    this.clauses.forEach((clause) => { console.log(`Cl√°usula: ${clause}`) });
    this.signatories.forEach((signatory) => { console.log(`Assinado por: ${signatory.name}`) });
    console.log('--------------------\n');
  }
}

const s1 = new SalesContract();
const pp1 = new NaturalPerson('Tony', '123456789');
const pp2 = new NaturalPerson('Lilly', '987654321');
const lp = new LegalPerson('International Sales SA', '23961237162378');

s1.describe();
s1.addClause('Foo');
s1.addClause('Bar');
s1.describe();
s1.sign(pp1);
s1.sign(pp2);
s1.describe();
s1.addClause('Baz');
s1.sign(lp);
s1.describe();

/*
Sa√≠da:
--------------------
Contrato: Sales
--------------------

--------------------
Contrato: Sales
Cl√°usula: Foo
Cl√°usula: Bar
--------------------

--------------------
Contrato: Sales
Cl√°usula: Foo
Cl√°usula: Bar
Assinado por: Tony
Assinado por: Lilly
--------------------

--------------------
Contrato: Sales
Cl√°usula: Foo
Cl√°usula: Bar
Assinado por: Tony
Assinado por: Lilly
Assinado por: International Sales SA
--------------------
 */
Existem muitas valida√ß√µes que n√£o foram feitas, visto que √© s√≥ um exemplo, mas j√° d√° pra ter uma ideia de como os conceitos de heran√ßa e interfaces facilitam a vida, n√£o √©?

Se quiser, brinque um pouco criando novos tipos de contratos e implemente mais funcionalidades üòé.