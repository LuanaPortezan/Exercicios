Implementando interfaces
Heran√ßa √© utilizada quando queremos codificar um comportamento padr√£o na superclasse, a fim de que as subclasses sigam esse comportamento, e tamb√©m quando queremos mais reutiliza√ß√£o de c√≥digo.

Atualmente, quando falamos de orienta√ß√£o a objetos, falamos tamb√©m de Orienta√ß√£o a Interfaces. Na heran√ßa, temos a ideia de que subclasses v√£o herdar m√©todos e atributos das superclasses. Quando estamos usando Interfaces, por√©m, temos uma class que vai implementar m√©todos definidos em uma interface. O objetivo √© desacoplar a implementa√ß√£o do contrato.

Na interface, n√≥s determinamos quais as assinaturas dos m√©todos e quais atributos o contrato deve respeitar. A interface por si s√≥ n√£o pode ser instanciada, ou seja, n√£o podemos usar ela junto com o new para criar um objeto novo. Ela √© apenas o contrato que ser√° implementado por uma classe.

Na interface n√£o implementamos nenhum c√≥digo, apenas definimos o contrato (atributos e assinatura dos m√©todos). A classe que implementar essa interface, deve, obrigatoriamente, implementar todos os m√©todos e ter todos os atributos que a interface declara.

Copiar
interface Animal {
  name: string;
  age: number;

  getBirthDate(): Date;
}

class Bird implements Animal {
  constructor(
    public name: string,
    private birthDate: Date) {}

  get age() {
    var timeDiff = Math.abs(Date.now() - new Date(this.birthDate).getTime());
    return Math.floor(timeDiff / (1000 * 3600 * 24) / 365.25);
  }

  getBirthDate() { return this.birthDate; }

  fly() { console.log(`${this.name} est√° voando!`); }
}

const parrot = new Bird(
  'Papagaio',
  new Date(Date.parse('Aug 16, 2015')),
);

console.log(parrot.age);
parrot.fly();

/*
Sa√≠da (c√≥digo executado em Mar/2022):
6
Papagaio est√° voando!
*/
Observe que a interface √© implementada por uma classe por meio da sintaxe class Classe implements Interface.

Importante salientar que a interface √© um contrato de tudo que a classe deve possuir de forma p√∫blica. Atributos privados precisam ter seu correspondente p√∫blico, e voc√™ pode usar getters e setters como uma forma p√∫blica de acessar atributos privados.

Observe tamb√©m que a classe Bird possui o m√©todo fly (voar), n√£o definido pela interface. A classe deve possuir todos atributos e m√©todos definidos na interface, mas n√£o necessariamente se limitar a eles üòâ.

O v√≠deo abaixo mostra a implementa√ß√£o de interfaces:


Para fixar:
Crie uma interface chamada MyInterface.

MyInterface deve possuir um atributo myNumber do tipo number.

MyInterface deve possuir um m√©todo myFunc, que recebe um par√¢metro myParam do tipo number e retorna uma string.

Crie uma classe MyClass que implementa MyInterface.

Fa√ßa o atributo myNumber ser inicializado diretamente nos par√¢metros do construtor da MyClass.

Fa√ßa o m√©todo myFunc somar o myNumber com o myParam e retornar uma string qualquer que contenha a soma.

Crie um objeto da classe MyClass e o utilize acessando myNumber e chamando myFunc.

