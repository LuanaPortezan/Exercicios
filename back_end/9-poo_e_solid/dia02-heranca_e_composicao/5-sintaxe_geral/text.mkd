Sintaxe geral
Vamos come√ßar criando uma classe Animal e uma classe Mam√≠fero, que herda de animal, e brincando um pouco com o uso.

Como s√£o muitos termos espec√≠ficos em ingl√™s, para este caso em espec√≠fico ser√° disponibilizado um dicion√°rio informal:

age: idade
birth date: data de nascimento
full year: ano completo (os 4 d√≠gitos)
mammal: mam√≠fero
name: nome
walk: andar
year: ano
Copiar
class Animal {
  /*
    Ao inv√©s de declarar os atributos antes do construtor, receber par√¢metros
    no construtor e coloc√°-los nos atributos da classe, se n√£o formos
    validar, podemos utilizar uma forma simplificada de escrita, simplesmente
    colocando o modificador de visibilidade na frente
    do nome do par√¢metro no construtor

    Exemplo
    O seguinte c√≥digo:

    public x: number
    constructor(x: number) { this.x = x }

    Pode ser substitu√≠do por:

    constructor(public x: number) { }
    
    Obs: Usando essa sintaxe √© necess√°rio indicar explicitamente 
    logo antes do nome do atributo se ele √© public, private, protected ou readonly
  */
  constructor(public name: string, private birthDate: Date) { }

  get age() {
    /*Para operar com datas, vamos operar somente com milissegundos. Uma data
    √© o n√∫mero de milissegundos desde o dia 01/01/1970 (era Unix).*/
    const timeDiff = Math.abs(
      Date.now() -
      new Date(this.birthDate).getTime()
    );

    /*Convertendo de volta para o n√∫mero de anos inteiros, considerando anos bissextos.
    Tente entender a l√≥gica abaixo: como converter de milissegundos para anos?*/
    return Math.floor(timeDiff / (1000 * 3600 * 24) / 365.25);
  }
}

class Mammal extends Animal {
  walk() {
    console.log(`${this.name} est√° andando!`);
  }
}

const tiger = new Mammal(
  'Tigre',
  new Date(Date.parse('May 03, 2020')),
);

const main = (animal: Animal) => {
  console.log(animal.age);
}

main(tiger);
tiger.walk();

/*
Sa√≠da (c√≥digo rodado em Mar/2022):
1
Tigre est√° andando!
*/
A sintaxe para criar uma classe que herda outra √© bem simples, basta utilizar a palavra reservada extends.

Observe que a fun√ß√£o main espera receber um par√¢metro do tipo Animal. Por√©m, o objeto passado para a fun√ß√£o √© o objeto tiger, que √© do tipo Mammal. Isso ocorre pois todo Mammal √© tamb√©m um Animal, ent√£o qualquer par√¢metro do tipo Animal pode receber um objeto de classes filhas. Essa √© a grande vantagem do polimorfismo por subtipagem (ou heran√ßa).

A fun√ß√£o main, por√©m, s√≥ entende um objeto do tipo Animal. Por isso ela n√£o consegue acessar nada restrito ao subtipo Mammal (tamb√©m conhecida como classe filha ou subclasse)! Voc√™ vai obter um erro que diz ‚Äúa propriedade ‚Äòwalk‚Äô n√£o existe no tipo Animal‚Äú.

Copiar
const main = (animal: Animal) => {
  console.log(animal.age);
  animal.walk(); // error: Property 'walk' does not exist on type 'Animal'.
}

main(tiger);
Nada nos impede de criar uma nova classe Ave (Bird) que tamb√©m herda de Animal e utiliz√°-la de forma similar, mas com suas especificidades (neste caso o m√©todo fly, voar):

Copiar
class Bird extends Animal {
  fly() {
    console.log(`${this.name} est√° voando!`);
  }
}

const parrot = new Bird(
  'Papagaio',
  new Date(Date.parse('Jun 07, 2017')),
);

console.log(parrot.age);
parrot.fly();

/*
Sa√≠da (c√≥digo executado em Mar/2022):
4
Papagaio est√° voando!
*/
O v√≠deo abaixo mostra o uso de heran√ßa com classes:


Para fixar:
Que tal exercitar a sintaxe um pouco, com um breve exerc√≠cio bem simples? Juro que parece muita coisa, mas n√£o √©!

Crie uma classe chamada Superclass.

A Superclass deve possuir um atributo p√∫blico isSuper

isSuper deve ser setado como true na inicializa√ß√£o.

A Superclass deve possuir um m√©todo p√∫blico chamado sayHello, que deve imprimir ‚ÄúOl√° mundo!‚Äù.

Crie uma classe chamada Subclass que herda da Superclass.

Crie uma fun√ß√£o myFunc fora do escopo da Subclass que recebe um objeto da Superclass.

Dentro dessa fun√ß√£o, chame o m√©todo sayHello do objeto passado como par√¢metro.
Crie um objeto da Superclass e outro da Subclass.

Chame a fun√ß√£o myFunc 2 vezes, passando os objetos criados.

Vamos agora a alguns t√≥picos um pouco mais avan√ßados, atributos protegidos e o uso do super.

Atributos protegidos
Observe que temos, na classe Animal, um atributo privado birthDate (data de nascimento). Voc√™ n√£o pode acessar ou alterar este atributo fora da classe Animal.

Copiar
class Animal {
  constructor(private birthDate: Date) { } // Repare no private

}
class Bird extends Animal {
  showBirthDate() {
    console.log(this.birthDate); // ERRO! birthDate √© privado e n√£o √© vis√≠vel pra subclasse Bird.
  }
}
Entretanto, √†s vezes precisamos manter alguns atributos e m√©todos privados do mundo externo, mas poss√≠veis de serem modificados dentro de subclasses. √â a√≠ que entra o protected.

Copiar
class Animal {
  constructor(protected birthDate: Date) { } // Protected: classe filha pode ler e escrever, mas acessos externos n√£o
}
class Bird extends Animal {
  showBirthDate() {
    console.log(this.birthDate); // Okay!
  }
}
Para fixar:
Com base no exemplo do exerc√≠cio anterior:

Comente a cria√ß√£o da inst√¢ncia da Superclass.

Comente a chamada da fun√ß√£o que recebe o objeto do tipo Superclass como argumento.

Fa√ßa a fun√ß√£o receber n√£o mais um objeto da Superclass, mas sim da Subclass.

Crie, na Subclass, um m√©todo p√∫blico chamado sayHello2.

Chame o m√©todo sayHello dentro do m√©todo sayHello2.

Mude a visibilidade do m√©todo sayHello de public para protected.

Ao mudar a visibilidade, o compilador (ou o vs code) vai mostrar um erro. Conserte esse erro utilizando o novo m√©todo sayHello2.

Mude a visibilidade do m√©todo sayHello de protected para private. O que acontece?

Obs: Desfa√ßa estas altera√ß√µes antes de fazer o pr√≥ximo exerc√≠cio, ou seja, deixe como estava ao final do primeiro exerc√≠cio.

Super
Sempre que voc√™, na subclasse, queira referenciar a superclasse, poder√° utilizar a palavra reservada super. Super bacana, n√©? ü§£

Deixando a gracinha de lado, vamos a um exemplo que n√£o funciona:

Copiar
class Animal {
  constructor(protected birthDate: Date) { }
}
class Bird extends Animal {
  constructor(public name: string) { } // ERRO: constructor deve respeitar o contrato da superclasse
}
Em TypeScript, o m√©todo construtor de uma subclasse deve ser o mesmo da superclasse (os exemplos anteriores funcionaram pois n√£o tinham o construtor), ou deve chamar o da superclasse.

Agora vamos a um exemplo que funciona:

Copiar
class Animal {
  constructor(protected birthDate: Date) { }
}
class Bird extends Animal {
  constructor(public name: string) {
    super(new Date());
  }
}
O super √© basicamente uma refer√™ncia √† superclasse. Ao ser invocado como uma fun√ß√£o, est√° invocando o construtor da superclasse.

Por fim, o super tamb√©m √© √∫til quando fazemos sobrescrita de m√©todos, um dos temas da pr√≥xima aula üòâ.

Para fixar:
Com base no final do primeiro exerc√≠cio de fixa√ß√£o:

No construtor da Subclass, o atributo isSuper deve ser setado como false. Voc√™ vai precisar utilizar o super.

Dentro da fun√ß√£o que recebe um objeto da Superclass como par√¢metro, cheque o valor do atributo isSuper e imprima no console ‚ÄúSuper!‚Äù se for true e ‚ÄúSub!‚Äù se for false;