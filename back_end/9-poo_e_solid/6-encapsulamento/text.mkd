Encapsulamento
Em nossa analogia, falamos brevemente sobre esse pilar. Vamos aprofundar um pouco mais nele agora!

O pilar do encapsulamento consiste na exibi√ß√£o e concess√£o de acesso para quem usa a classe apenas daquilo que ela pode/deve de fato ver ou interagir.

A ideia √© garantir que os processos internos da classe possam ocorrer sem que a pessoa que a utiliza altere atributos de forma indevida, o que poderia ocasionar em problemas no funcionamento. Para isso existem os modificadores de visibilidade do atributo, sendo os principais o public, o private, o protected e o readonly. O protected vai ser apresentado juntamente com heran√ßa.

Os atributos criados sem modificadores de visibilidade s√£o p√∫blicos por padr√£o, e podem ser acessados e alterados tanto dentro quanto fora da classe. Se quisermos deixar expl√≠cito que n√£o esquecemos de colocar a visibilidade adequada, podemos utilizar a palavra reservada public na frente do atributo.

J√° os atributos criados com o modificador private s√≥ podem ser lidos e modificados dentro da classe. Isso significa que se voc√™ tentar utilizar a nota√ß√£o objeto.atributo do lado de fora das chaves que delimitam a cria√ß√£o da classe, voc√™ ter√° um erro do compilador.

Por fim, os atributos criados com o modificador readonly podem ser lidos em qualquer lugar, mas s√≥ podem ser inicializados uma vez, no construtor. Apesar desse modificador n√£o estar exatamente ligado a Orienta√ß√£o a Objetos, √© importante entender seu funcionamento üòâ.

Para alterar atributos privados fora de uma classe, utilizamos os m√©todos. Eles validam as leituras e altera√ß√µes, de forma a n√£o comprometer o funcionamento da classe. Por exemplo, voc√™ pode ter uma classe Pessoa com o atributo dataDeNascimento privado, e possuir um m√©todo para mudar esta data de nascimento de forma a validar se √© digitada uma data v√°lida. Para ler os valores dos atributos, podemos criar os m√©todos getters, e para modificar, os m√©todos setters. √â importante salientar que atributos privados n√£o s√£o obrigados a ter getters e setters. Eles s√≥ precisam destes m√©todos caso seja necess√°rio alter√°-los diretamente, podendo garantir uma valida√ß√£o do dado que foi passado. Veremos mais sobre isso na parte de sintaxe.

A depender da filosofia da linguagem que se utiliza, uma boa pr√°tica √© deixar todos os atributos como privados e criar os getters e setters de acordo com a necessidade de cada atributo. Uma outra pr√°tica muito comum √© o uso de um underline antes do nome de atributos privados.